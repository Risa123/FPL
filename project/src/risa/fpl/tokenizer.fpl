use{
 std.io.base
 std.collection
 risa.fpl.base
 std.backend
}
enum TokenType NEW_LINE ID CHAR_LIT END_BLOCK BEGIN_BLOCK STRING
class Token{
  private const{
   int line;tokenNum
   String value
   TokenType type
  }
  this int line int tokenNum String value TokenType type{
    this line = line
    this tokenNum = tokenNum
    this value = value
    this type = type
  }
  fn int getLine = line
  fn int getTokenNum = tokenNum
  fn String getValue = value
  fn TokenType getType = type
}
class Tokenizer{
 private{
    int line 1;tokenNum 1;i 0
    char c
    bool readNext false
    DataReader* reader
    const ArrayList;Token; tokens
    fn void token int line int tokenNum String value TokenType type{
     tokens add Token:new line,tokenNum,value,type
     if type == TokenType:NEW_LINE{
       this line ++
       this tokenNum = 1
     }{
       this tokenNum ++
     }
    }
    fn char read{
      if readNext{
       c = reader readChar
      }{
       readNext = true
      }
      return c
    }
    fn bool ready = reader ready; || readNext !
    fn void valueToken int line int tokenNum ArrayList;char;* b TokenType type{
      var p char:alloc[] b getSize
      memoryCopy b getArray;cast byte*,p cast byte*,b getSize
      String id p,b getSize;cast uint,true
      token tokenNum,line,id,type
    }
    fn void prepare{
      if tokens getSize; == i{
           tokens clear
           i = 0
      }
      if tokens isEmpty{
       while ready{
         read
         if c == $({
            while ready; && read; == $){}
          }if c == $#{
            while ready; && read; == $\n{}
          }if c == $${
           if ready; !{
              CompilerException:new line,tokenNum,"char expected";throw
            }
            ArrayList;char; b
            b add $'
            var firstChar read
            if firstChar == $\\{
              if ready; !{
               CompilerException:new line,tokenNum,"character expected";throw
              }
               if c == $t; || c == $n; || c == $f; || c == $b; || c == $r; || c == $\\; || c == $0{
                  b add $\\
                  b add c
               }if c == $s{
                 b add $\s
               }{
                CompilerException:new line,tokenNum,"no special character called " + c toString;;;throw
               }
              }if firstChar isWhitespace{
                CompilerException:new line,tokenNum,"$ cannot be followed by whitespace";throw
               }{
                b add firstChar
               }
               b add $'
               b add $\0
               valueToken line,tokenNum,b ref,TokenType:CHAR_LIT
             }if c == $\n{
               token line,tokenNum,"\n",TokenType:NEW_LINE
               break
             }if c == ${{
               token line,tokenNum,"{",TokenType:BEGIN_BLOCK
             }if c == $}{
               token line,tokenNum,"}",TokenType:END_BLOCK
             }if c == $"{
              ArrayList;char; b
              b add $"
              while ready; && read; != $"{
                if c == $\n{
                  CompilerException:new line,tokenNum,"expected \"";throw
                }
                if c == $\\{
                  b add $\\
                  if ready; !{
                    CompilerException:new line,tokenNum,"character expected";throw
                  }
                  read #appended in following lines
                }
                b add c
              }
              b add $"
              valueToken line,tokenNum,b ref,TokenType:STRING
             }if c isWhitespace;!{
               ArrayList;char; b
               b add c
               while ready{
                 read
                 if isSeparator{
                  readNext = false
                  break
                 }
                 b add c
               }
               valueToken line,tokenNum,b ref,TokenType:ID
             }
            }
         }
    }
    fn bool isSeparator =  c isWhitespace; ||  c == ${; || c == $}; || c == $; #char ;
 }
 this Readable readable{
    reader = DataReader:alloc readable
 }
 fn Token next{
    var token peek
    i ++
    return token
 }
 fn Token peek{
   prepare
   if tokens isEmpty{
     CompilerException:new line,tokenNum,"no tokens available";throw
   }
   return tokens get i
 }
 fn void close{
   reader close
 }
 fn bool hasNext{
  prepare
  return tokens isEmpty; !
 }
 fn Token nextID{
   var id next
   if id getType; != TokenType:ID{
     CompilerException:new id getLine;,id getTokenNum;,"identifier expected instead of " + id getValue;;;throw
   }
   return id
 }
 -this{
   reader free
 }
}