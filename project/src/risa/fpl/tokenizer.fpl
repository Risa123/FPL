use{
 std.io.base
 std.collection
 risa.fpl.base
 std.backend
}
enum TokenType NEW_LINE ID CHAR_LIT END_BLOCK BEGIN_BLOCK STRING
final class Token{
  private const{
   int line;tokenNum
   String value
   TokenType type
  }
  this int line int tokenNum String value TokenType type{
    this line = line
    this tokenNum = tokenNum
    this value = value
    this type = type
  }
  fn int getLine = line
  fn int getTokenNum = tokenNum
  fn String getValue = value
  fn TokenType getType = type
  fn String toString = value
}
final class Tokenizer{
 private{
    int line 1;tokenNum 1;i 0
    char c
    bool readNext true
    const{
       DataReader reader
       ArrayList;Token; tokens init
    }
    fn void token String value TokenType type{
     tokens add Token:new line,tokenNum,value,type
     if type == TokenType:NEW_LINE{
       this line ++
       this tokenNum = 1
     }{
       this tokenNum ++
     }
    }
    fn char read{
      if readNext{
       c = reader readChar
      }{
       readNext = true
      }
      return c
    }
    fn bool ready = reader ready; || readNext !
    fn void valueToken ArrayList;char;* b TokenType type{
      var p char:alloc[] b getSize
      memoryCopy b getArray;cast byte*,p cast byte*,b getSize
      String id init p,b getSize;cast uint,true
      token id,type
    }
    fn void prepare{
      if tokens getSize; == i{
           tokens clear
           i = 0
      }
      if tokens isEmpty{
       while ready{
         read
         if c == $({
            while ready; && read; == $){}
          }if c == $#{
            while ready; && read; == $\n{}
          }if c == $${
           if ready; !{
              CompilerException:throw line,tokenNum,"char expected"
            }
            ArrayList;char; b init
            b add $'
            var firstChar read
            if firstChar == $\\{
              if ready; !{
               CompilerException:throw line,tokenNum,"character expected"
              }
               if c == $t; || c == $n; || c == $f; || c == $b; || c == $r; || c == $\\; || c == $0{
                  b add $\\
                  b add c
               }if c == $s{
                 b add $\s
               }{
                CompilerException:throw line,tokenNum,"no special character called " + c toString
               }
              }if firstChar isWhitespace{
                CompilerException:throw line,tokenNum,"$ cannot be followed by whitespace"
               }{
                b add firstChar
               }
               b add $'
               b add $\0
               valueToken b ref,TokenType:CHAR_LIT
             }if c == $\n{
               token "\n",TokenType:NEW_LINE
               break
             }if c == ${{
               token "{",TokenType:BEGIN_BLOCK
             }if c == $}{
               token "}",TokenType:END_BLOCK
             }if c == $"{
              ArrayList;char; b init
              b add $"
              while ready; && read; != $"{
                if c == $\n{
                  CompilerException:throw line,tokenNum,"expected \""
                }
                if c == $\\{
                  b add $\\
                  if ready; !{
                    CompilerException:throw line,tokenNum,"character expected"
                  }
                  read
                }
                b add c
              }
              b add $"
              valueToken b ref,TokenType:STRING
             }if c isWhitespace;!{
               ArrayList;char; b init
               b add c
               while ready{
                 read
                 if isSeparator{
                  readNext = false
                  break
                 }
                 b add c
               }
               valueToken b ref,TokenType:ID
             }
            }
         }
    }
    fn bool isSeparator = c isWhitespace; ||  c == ${; || c == $}; || c == $; #char ;
 }
 this Readable readable = reader = DataReader:new readable
 fn Token next{
    var token peek
    i ++
    return token
 }
 fn Token peek{
   prepare
   if tokens isEmpty{
     CompilerException:throw line,tokenNum,"no tokens available"
   }
   return tokens get i
 }
 fn void close = reader close
 fn bool hasNext{
  prepare
  return tokens isEmpty; !
 }
 fn Token nextID{
   var id next
   if id getType; != TokenType:ID{
     CompilerException:throw id getLine;,id getTokenNum;,"identifier expected instead of " + id getValue
   }
   return id
 }
}