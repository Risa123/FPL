
class ArrayList;T{
 private{
  T* array
  memory len
  fn void checkIndex memory index{
    if index >= len{
      Exception:new "index out of bounds:" + index toString;;;throw
    }
  }
  fn void freeArray{
    array free[] len
 }
 this{
   len = 0
   array = nil
 }
 fn T get memory index{
   checkIndex index
   return array get index
 }
 fn void set memory index T value{
   checkIndex index
   array set index,value
 }
 fn void add T value{
   var oldLen len
   len ++
   if array == nil{
      array = malloc value getObjectSize;cast T*
      array drf= value
   }{
    array = realloc array cast void*,len * T:getInstanceSize;cast T*
    memoryCopy value ref cast byte*,array cast byte* + T:getInstanceSize * oldLen,T:getInstanceSize
   }
 }
 fn void clear{
  len = 0
  if array != nil{
    freeArray
    array = nil
  }
 }
 }
 fn bool isEmpty = len == 0
 fn memory getSize = len
 fn T* getArray = array
 -this{
   if array != nil{
     freeArray
   }
 }
}
class Entry;K V{
  private{
   K key
   V value
  }
  this K key V value{
    this key = key
    this value = value
  }
  fn K getKey = key
  fn V getValue = value
  fn void setKey K key = this key = key
  fn void setValue V value = this value = value
}
class Map;K V{
  private const ArrayList;Entry;K V;; entries
  fn void put K key V value{
    var notPresent true
    var i 0L
    while i < entries getSize{
      var entry entries get i
      if entry getKey; == key{
        entry setValue value
        notPresent = false
        break
      }
      i ++
    }
    if notPresent{
      entries add Entry;K V:new key,value
    }
  }
  fn bool containsKey K key{
    var i 0L
    while i < entries getSize{
      if entries get i;getKey; == key{
        return true
      }
      i ++
    }
    return false
  }
  fn V get K key{
    var i 0L
    while i < entries getSize{
      var entry entries get i
      if entry getKey; == key{
        return entry getValue
      }
      i ++
    }
    Exception:new "map has no entry for key";throw
  }
}