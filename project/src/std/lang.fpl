(#this module is imported automatically)
use std.backend

fn void print char c = putchar c
class String{
  private{
    char* p
    uint len
    bool allocated
  }
  this char* p uint len bool allocated{
    this len = len
    this p = p
    this allocated = allocated
  }
  -this{
    if allocated{
       p free
    }
  }
  fn void set uint index char c{
    native fn void _std_lang_checkStringIndex0 uint len uint index
    _std_lang_checkStringIndex0 len,index
    p set index,c
  }
  fn char get uint index{
    native fn void _std_lang_checkStringIndex0 uint len uint index
    _std_lang_checkStringIndex0 len,index
    return p get index
  }
  fn bool == String str{
    if len != str len{
      return false
    }
    var i 0
    while i < len{
      if p get i; != str p get i{
        return false
      }
      i ++
    }
    return true
  }
  fn String + String str{
    var ret char:alloc[] len + str len
    var i 0
    while i < len{
       ret set i,p get i
       i ++
    }
    var strI 0
    while strI < str len{
      ret set i,str p get strI
      strI ++
      i ++
    }
    return String:new ret,len + str len,true
  }
  fn char* toCString{
    var ret char:alloc[] len + 1
    var i 0
    while i < len{
      ret set i,p get i
      i ++
    }
    ret set i,$\0
    return ret
  }
  =this{
    len = o len
    p = char:alloc[] len
    memoryCopy o p,p,len
    allocated = true
  }
  fn void = String str{
    len = str len
    p = char:alloc[] len
    memoryCopy str p,p,len
    allocated = true
    if allocated && p == nil{
      p free
    }
  }
  fn uint getLength = len
  fn String toString = this drf
}
fn void print String str{
   var cstr str toCString
   puts cstr
   cstr free
}
fn void checkStringIndex uint len uint index{
    if index >= len{
       Exception:new "index out of bounds:" + integerToString index;;;throw
    }
 }
class EHEntry{
   EHEntry* prev
   Context context
   void** exceptionTypes
   int exceptionTypesLen
}
class Exception{
   protected String message
   this String message{
     this message = message
   }
   virtual fn String getMessage = message
   fn void throw{
     var target currentThread currentEHEntry
     var stop false
     while target != nil{
      var i 0
      while i < target exceptionTypesLen{
      if target exceptionTypes get i; == getClass{
           stop = true
           break
      }
      i ++
     }
     if stop{
       break
     }
     target = target prev
     }
     if target == nil{
       currentThread exceptionHandler drf this
       return
     }
     currentThread exception = std.backend.malloc getObjectSize;cast Exception*
     if currentThread exception == nil{
        print "unable to allocate exception"
        exit 1
     }
     memoryCopy this cast byte*,currentThread exception cast byte*,getObjectSize
     contextRestore target context
   }
   #DO NOT REMOVE used in try-catch-finally
   internal fn void copyAndFree Exception* target{
       memoryCopy this cast byte*,target cast byte*,getObjectSize
       target message = message
       this free
   }
}
fpointer void ExceptionHandlerType Exception* ex
class Thread{
 private String name
 internal{
   Exception* exception
   EHEntry* currentEHEntry
   ExceptionHandlerType exceptionHandler
   fn void addEHEntry void** exceptionTypes int exceptionTypesLen{
        var prev currentEHEntry
        currentEHEntry = EHEntry:alloc
        currentEHEntry prev = prev
        currentEHEntry exceptionTypes = exceptionTypes
        currentEHEntry exceptionTypesLen = exceptionTypesLen
    }
    fn void removeEHEntry{ #exceptionTypes is not dynamically allocated
      var prev currentEHEntry prev
      currentEHEntry free
      currentEHEntry = prev
    }
     fn void freeEHEntries{
       while currentEHEntry != nil{
         var prev currentEHEntry prev
         currentEHEntry free
         currentEHEntry = prev
       }
     }
 }
 this String name{
   this name = name
   currentEHEntry = nil
   setExceptionHandler &defaultExceptionHandler
 }
 fn void setName String name = this name = name
 fn String getName = name
 fn void setExceptionHandler ExceptionHandlerType exceptionHandler = this exceptionHandler = exceptionHandler
}
Thread* currentThread #initailized in main block
fn void defaultExceptionHandler Exception* ex{
  print "exception happened:"
  print ex getMessage
  exit 1
}
fn void* realloc void* p memory newSize{
  p = std.backend.realloc p,newSize
  if p == nil{
    Exception:new "reallocation of memory failed";throw
  }
  return p
}
fn void* malloc memory size{
  var p std.backend.malloc size
  if p == nil{
    Exception:new "allocation of memory failed";throw
  }
  return p
}
fn void memoryCopy byte* src byte* dest memory size{
    memory i 0L
    while i < size{
     dest set i,src get i
     i ++
    }
}
#these functions will be made inaccessible by compiler
#char methods
fn bool isDigit char this{
  var c this cast int
  return c >= 48; && c <= 57
}
fn bool isWhitespace char this{
  var c this cast int
  return c <= 32; || c == 127
}
fn bool isControl char this{
  var c this cast int
  return c <= 31; || c == 127
}
fn bool isLetter char this{
  var c this cast int
  return c >= 65; &&  c <= 132; || c >= 97; && c <= 122
}
fn bool isLower char this{
  var c this  cast int
  return c <= 122; || c >= 97
}
fn bool isUpper char this{
  var c this cast int
  return c <= 90; || c >= 65
}
fn bool isBlank char this = this == $\s ; || this == $\t
fn bool isHexDigit char this{
  var c this cast int
  return isDigit this; || c >= 65; && c <= 70; || c >= 97; && c <= 102
}
fn bool isPrint char this{
  var c this cast int
  return c <= 176; || c >= 32
}
fn bool isGraph char this = isPrint this; || this == $\s
fn bool isPunct char this = isGraph this; && isLetter this
fn char toLower char this{
  if isUpper this{
     return $a cast byte + this cast byte  - $A
  }
  return this
}
fn char toUpper char this{
 if isLower this{
   return $A cast byte + this cast byte  - $a
 }
 return this
}
fn String charToString char this{
  var b char:alloc[] 1
  String str init b,1,true
  str set 0,this
  return str
}
#bool methods
fn String boolToString bool this{
   if this{
     return "true"
   }
   return "false"
}
#integer methods
fn String integerToString long this{
 [] char 20 buf
 int i 0
 var negative false
 if this < 0{
   this = this -
   negative = true
 }
 while this > 0;|| i == 0{
  var code this % 10 + $0 cast byte
  buf set i,code cast char
  this /= 10
  i ++
 }
 var j 0
 var len i --
 if negative{
   j = 1
   len ++
 }
 var ret char:alloc[] i
 if negative{
   ret set 0,$-
 }
 while j < len{
   ret set j,buf get i
   j ++
   i --
 }
 return String:new ret,len,true
}