(#this module is imported automatically)
use std.backend

class Exception{
   private{
     string message
     bool allocatedMessage
   }
   this string message{
     this message = message
   }
   fn void allocateMessage = allocatedMessage = true
   virtual fn string getMessage = message
   fn void throw{
     if currentThread currentEHentry == nil{
       currentThread exceptionHandler drf this
       return
     }
     native fn void* malloc memory size
     currentThread exception = malloc getObjectSize; cast Exception*
     if currentThread exception == nil{
        puts "unable to allocate exception"
        exit 1
     }
     memoryCopy this cast byte*,currentThread exception cast byte*,getObjectSize
     contextRestore currentThread currentEHentry context
   }
   internal fn void copyAndFree Exception* to{
     memoryCopy this cast byte*,to cast byte*,getObjectSize
     this free
   }
   -this{
     if allocatedMessage{
       message free
     }
   }
}
fpointer void ExceptionHandlerType Exception* ex
private class EHentry{
  EHentry* prev
  Context context
}
class Thread{
 private string name
 internal{
   Exception* exception
   EHentry* currentEHentry
   ExceptionHandlerType exceptionHandler
   fn void addEHentry{
        var prev currentEHentry
        currentEHentry = EHentry:alloc
        currentEHentry prev = prev
    }
    fn void removeEHentry{
      var prev currentEHentry prev
      currentEHentry free
      currentEHentry = prev
    }
 }
 (#do not call)
 fn void freeEHentries{
   while currentEHentry != nil{
     var prev currentEHentry prev
     currentEHentry free
     currentEHentry = prev
   }
 }
 this string name{
   this name = name
   currentEHentry = nil
   setExceptionHandler &defaultExceptionHandler
 }
 fn void setName string name = this name = name
 fn string getName = name
 fn void setExceptionHandler ExceptionHandlerType exceptionHandler{
   this exceptionHandler = exceptionHandler
 }
}
class String{
  private{
    char* p
    uint len
    bool allocated
  }
  this char* p uint len bool allocated{
    this len = len
    this p = p
    this allocated = allocated
  }
  -this{
    if allocated{
       p free
    }
  }
}
Thread* currentThread
fn void defaultExceptionHandler Exception* ex{
  puts "exception happened:"
  puts ex getMessage
  ex free
  exit 1
}
fn void* realloc void* p memory newSize{
  p = realloc p,newSize
  if p == nil{
    Exception ex "reallocation of memory failed"
    ex throw
  }
  return p
}
fn void* malloc memory size{
  var p malloc size
  if p == nil{
    Exception ex "allocation of memory failed"
    ex throw
  }
  return p
}
fn void memoryCopy byte* src byte* dest memory size{
    memory i 0L
    while i < size{
     dest set i,src get i
     i ++
    }
}
alias free free
#these functions will be made inaccessible by compiler
#string methods
fn uint getLength string this{
  var length 0
  while this get length; != $\0{
      length ++
  }
  return length
}
fn bool == string this string str{
   var len getLength this
   if len != getLength str{
      return false
   }
   var i 0
   while i < len{
      if this get i; != $\0{
         return false
      }
      i ++
   }
   return true
}
fn string + string this string str{
  var thisLen getLength this
  var strLen getLength str
  var ret new thisLen + strLen + 1
  var i 0
  while i < thisLen{
     ret set i,this get i
     i ++
  }
  var strI 0
  while strI < strLen{
    ret set i,str get strI
    strI ++
    i ++
  }
  ret set i,$\0
  return ret
}
fn string new uint len{
  return malloc len; cast string
}
#char methods
fn bool isDigit char this{
  var c this cast int
  return c >= 48; && c <= 57
}
fn bool isWhitespace char this{
  var c this cast int
  return c <= 32; || c == 127
}
fn bool isControl char this{
  var c this cast int
  return c <= 31; || c == 127
}
fn bool isLetter char this{
  var c this cast int
  return c >= 65; &&  c <= 132; || c >= 97; && c <= 122
}
fn bool isLower char this{
  var c this  cast int
  return c <= 122; || c >= 97
}
fn bool isUpper char this{
  var c this cast int
  return c <= 90; || c >= 65
}
fn bool isBlank char this{
  return this == $\s ; || this == $\t
}
fn bool isHexDigit char this{
  var c this cast int
  return isDigit this; || c >= 65; && c <= 70; || c >= 97; && c <= 102
}
fn bool isPrint char this{
  var c this cast int
  return c <= 176; || c >= 32
}
fn bool isGraph char this = isPrint this; || this == $\s
fn bool isPunct char this = isGraph this; && isLetter this
fn char toLower char this{
  if isUpper this{
     return $a cast int + this cast int  - $A
  }
  return this
}
fn char toUpper char this{
 if isLower this{
   return $A cast int + this cast int  - $a
 }
 return this
}
fn string charToString char this{
  var str new 2
  str set 0,this
  str set 1,$\0
  return str
}
#bool methods
fn string boolToString bool this{
   if this{
     return "true"
   }
   return "false"
}
#integer methods
fn string integerToString long this{
 [] char 20 buf
 int i 0
 while this > 0;|| i == 0{
  buf set i,this % 10 + $0
  this /= 10
  i ++
 }
 buf set i,$\0
 var ret new 21
 int j 0
 while j < 20{
   ret set j,buf get j
   if buf get j; == $\0{
     break
   }
   j ++
 }
 return ret
}