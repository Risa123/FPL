native {
 fn int puts string str
 fn void* malloc memory size
 fn void free void* p
 fn void exit int exitCode
 fn void* realloc void* p memory new_size
 private {
    fn memory fwrite void* p memory size memory nmen
    fn bool feof void* file
    fn int system string cmd
    fn void* fopen string name string mode
    fn memory fread void* p memory size memory msize void* file
    fn void fclose void* file
    fn int fflush void* file
    fn void* __acrt_iob_func uint index
    fn int setvbuf void* file byte* buffer int mode memory size
 }
}
private const int STDIN_INDEX 0;STDOUT_INDEX 1;STDERR_INDEX 2
void* stdin __acrt_iob_func STDIN_INDEX
void* stdout __acrt_iob_func STDOUT_INDEX
void* stderr __acrt_iob_func STDERR_INDEX
int IO_FULL_BUFFER 0x0000 #_IOFLBF
int IO_LINE_BUFFER 0x0040 #_IOLBF
int IO_NO_BUFFER 0x0004 #_IONBF
fn int execute string cmd {
  return system cmd
}
fn void fileClose void* file {
  fclose file
}
fn void* fileOpen string name string mode {
   return fopen name,mode
}
fn memory fileRead void* file byte* p memory size {
  return fread p cast void*,size,1,file
}
fn memory fileWrite void* file byte* p memory size {
  return fwrite p cast void*,size,1
}
fn bool fileEOF void* file{
   return feof file
}
fn int fileFlush void* file{
  return fflush file
}
fn int fileSetBuffer void* file byte* buffer int mode memory size{
   return setvbuf file,buffer,mode,size
}
cstruct ContextData{
  if_flag x86_64{
    long rbx;rsp;rbp;r12;r13;r14;r15;rip
  }
  if_flag x86{
    int ebx;esp;ebp;r12;r13;r14;r15;eip
  }
}
#rcx is register for first argument on x86_64 win
asm "contextSave:"
#saving registers
if_flag x86_64{
 asm "movq %rbx,0(%rcx)"
 asm "movq %rsp,8(%rcx)"
 asm "movq %rbp,16(%rcx)"
 asm "movq %r12,24(%rcx)"
 asm "movq %r13,32(%rcx)"
 asm "movq %r14,40(%rcx)"
 asm "movq %r15,48(%rcx)"
 asm "movq 0(%rsp),%rdx" #get rta
 asm "movq %rdx,56(%rcx)" #save save instruction pointer
 asm "xorl %eax,%eax"
}
if_flag x86{
 asm "mov %ebx,0(%ecx)"
 asm "mov %esp,4(%ecx)"
 asm "mov %ebp,8(%ecx)"
 asm "mov %r12,12(%ecx)"
 asm "mov %r13,16(%ecx)"
 asm "mov %r14,20(%ecx)"
 asm "mov %r15,24(%ecx)"
 asm "mov 0(%esp),%edx" #get rta
 asm "mov %edx,56(%ecx)" #save save instruction pointer
}
asm "xorl %eax,%eax"
asm "ret"
asm "contextRestore:"
#restoring registers
if_flag x86_64{
 asm "movq 0(%rcx),%rbx"
 asm "movq 8(%rcx),%rsp"
 asm "movq 16(%rcx),%rbp"
 asm "movq 24(%rcx),%r12"
 asm "movq 32(%rcx),%r13"
 asm "movq 40(%rcx),%r14"
 asm "movq 48(%rcx),%r15"
 asm "movq %rdx,0(%rsp)"
}
if_flag x86{
 asm "mov 0(%ecx),%ebx"
 asm "mov 4(%ecx),%esp"
 asm "mov 8(%ecx),%ebp"
 asm "mov 12(%ecx),%r12"
 asm "mov 16(%ecx),%r13"
 asm "mov 20(%ecx),%r14"
 asm "mov 24(%ecx),%r15"
 asm "mov %edx,0(%esp)"
}
asm "xorl %eax,%eax"
asm "incl %eax"
asm "ret"
asm ".globl saveContext"
asm ".globl restoreContext"